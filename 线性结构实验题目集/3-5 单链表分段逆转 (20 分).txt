//我们这里就假设K为4；

void K_Reverse( List L, int K )
{
    PtrToNode r, p, end1,end2 ,H = L->Next;//_ 1 2 3 4 5 6 7 8 9 10  11 12    
    /**end1和end2是用来连接两个逆置后的分段；
       一开始我们令end1指向头节点，end2指向数据1所在的节点，为什么这样做呢？
       因为前四个数据我们都要把他以头插入方式插到L后面，也就是end1后面；
       当我们遍历到节点5的时候我们需要令end1 = end2；end2 = 5所在的节点；
       然后我们需要将5 6 7 8再以头插入的方式插入到1节点的后面，也就是end1的后面
       也就是说我们一直将节点以头插入的方式插入到end1后面，而end2使用来记录下一个
       分段的第一个节点，也就是下一个end1，就这样不断更新end1就可以实现将整个链表
       分段逆置；这是end1和end2的作用
    */
    end1 = L;
    end2 = L->Next;
    r = L->Next;	//用来遍历链表
    p = r->Next;    
    int count = 0;      
    /**
    	count用来记录链表节点总数；
    	为什么要记录总数？
    	因为我们要知道链表最后一个分段是不足K个节点，还是刚好K个节点；
    	如果不足就不用逆置，如果刚好也要把这一分段逆置了；
    */
    if (K>=1)		    //这里就是我上面说的考虑K的情况
    {    
    	//记录总数
        while (H)        
        {            
        count++;            
        H = H->Next;        
        }
                
        //判断，如果总数小于K就不变链表
        if (count>=K)        
        {
       	    /**count/K是我们总共需要循环几个分段，因为count/K结果去商，
       	       所以如果count不能被K整除，即最后一个分段不足K个，我们就不循环
       	       也就是不动它。
       	    */            
            for (int j = 0;j<count/K;j++)            
            {                
            	//每个分段循环K次
                for(int i = 0; i < K; i++)                
                {                    
                    r->Next = end1->Next;	//头插入
                    end1->Next = r;
                    r = p;
                    /**
                     这里为什么要判断p不为空呢？
                     因为我一开令r = L->Next;
                     		p = r->Next;
                     所以最后p会指向链表最后的Next域，而Next为空，就不
                     存在p的Next域，如果不判断的话程序运行到此处就不会再运行下去
                     而程序一开始编译的时候不会报错，所以这一点很重要，即判断越界
                     问题，我也是找了很长时间才找点这一点。
                    */                      
                    if(p)
                        p = p->Next;                
                 }
                end1 = end2;	//更新end1和end2                
                end2 = r;            
            }            
            end1->Next = r;	//最后将尾节点Next域置空。
        }
    }
}